<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Self-Evolution Dashboard - è‡ªæˆ‘è¿›åŒ–æ§åˆ¶å°</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', sans-serif;
        }
        .card {
            @apply bg-white rounded-lg shadow-md p-6 mb-6;
        }
        .stat-card {
            @apply bg-gradient-to-br from-blue-500 to-blue-600 text-white rounded-lg p-6 shadow-lg;
        }
        .badge {
            @apply inline-block px-3 py-1 rounded-full text-sm font-medium;
        }
        .badge-success { @apply bg-green-100 text-green-800; }
        .badge-warning { @apply bg-yellow-100 text-yellow-800; }
        .badge-danger { @apply bg-red-100 text-red-800; }
        .badge-info { @apply bg-blue-100 text-blue-800; }
    </style>
</head>
<body class="bg-gray-50 min-h-screen">
    <!-- Header -->
    <header class="bg-gradient-to-r from-blue-600 to-indigo-700 text-white shadow-lg">
        <div class="container mx-auto px-6 py-6">
            <div class="flex items-center justify-between">
                <div>
                    <h1 class="text-3xl font-bold">ğŸ§¬ Self-Evolution Dashboard</h1>
                    <p class="text-blue-100 mt-1">Claude Code Skill è‡ªæˆ‘è¿›åŒ–ç›‘æ§ç³»ç»Ÿ</p>
                </div>
                <div class="text-right">
                    <p class="text-sm text-blue-100">æœ€åæ›´æ–°</p>
                    <p class="text-lg font-semibold" id="lastUpdate">åŠ è½½ä¸­...</p>
                </div>
            </div>
        </div>
    </header>

    <div class="container mx-auto px-6 py-8">
        <!-- Status Cards -->
        <div class="grid grid-cols-1 md:grid-cols-4 gap-6 mb-8">
            <div class="stat-card">
                <p class="text-blue-100 text-sm mb-2">æ€»æ‰§è¡Œæ¬¡æ•°</p>
                <p class="text-4xl font-bold" id="totalExecutions">-</p>
                <p class="text-blue-100 text-sm mt-2">æœ€è¿‘ 30 å¤©</p>
            </div>

            <div class="stat-card" style="background: linear-gradient(135deg, #10b981, #059669);">
                <p class="text-green-100 text-sm mb-2">å¹³å‡è´¨é‡åˆ†æ•°</p>
                <p class="text-4xl font-bold" id="avgQuality">-</p>
                <p class="text-green-100 text-sm mt-2">0-1 èŒƒå›´</p>
            </div>

            <div class="stat-card" style="background: linear-gradient(135deg, #f59e0b, #d97706);">
                <p class="text-yellow-100 text-sm mb-2">å‘ç°çš„æ¨¡å¼æ•°</p>
                <p class="text-4xl font-bold" id="patternsCount">-</p>
                <p class="text-yellow-100 text-sm mt-2">æˆåŠŸæ¨¡å¼</p>
            </div>

            <div class="stat-card" style="background: linear-gradient(135deg, #8b5cf6, #7c3aed);">
                <p class="text-purple-100 text-sm mb-2">å¯ç”¨æ¨¡æ¿æ•°</p>
                <p class="text-4xl font-bold" id="templatesCount">-</p>
                <p class="text-purple-100 text-sm mt-2">å·²ç”Ÿæˆ</p>
            </div>
        </div>

        <!-- Quality Trends -->
        <div class="card">
            <h2 class="text-2xl font-bold mb-4 flex items-center">
                ğŸ“ˆ è´¨é‡è¶‹åŠ¿
                <span class="ml-auto text-sm font-normal text-gray-500">æœ€è¿‘ 30 å¤©</span>
            </h2>
            <canvas id="qualityChart" height="80"></canvas>
        </div>

        <!-- Two Column Layout -->
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
            <!-- Recent Executions -->
            <div class="card">
                <h2 class="text-2xl font-bold mb-4">ğŸ“ æœ€è¿‘æ‰§è¡Œè®°å½•</h2>
                <div id="recentExecutions" class="space-y-3">
                    <p class="text-gray-500 text-center py-8">åŠ è½½ä¸­...</p>
                </div>
            </div>

            <!-- Success Patterns -->
            <div class="card">
                <h2 class="text-2xl font-bold mb-4">âœ¨ æˆåŠŸæ¨¡å¼</h2>
                <div id="successPatterns" class="space-y-3">
                    <p class="text-gray-500 text-center py-8">åŠ è½½ä¸­...</p>
                </div>
            </div>
        </div>

        <!-- Templates Library -->
        <div class="card">
            <h2 class="text-2xl font-bold mb-4">ğŸ“š æ¨¡æ¿åº“</h2>
            <div id="templatesLibrary" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                <p class="text-gray-500 text-center py-8 col-span-full">åŠ è½½ä¸­...</p>
            </div>
        </div>

        <!-- Scheduler Status -->
        <div class="card">
            <h2 class="text-2xl font-bold mb-4">â±ï¸ è°ƒåº¦å™¨çŠ¶æ€</h2>
            <div id="schedulerStatus">
                <p class="text-gray-500 text-center py-8">åŠ è½½ä¸­...</p>
            </div>
        </div>
    </div>

    <!-- Footer -->
    <footer class="bg-white border-t mt-12 py-6">
        <div class="container mx-auto px-6 text-center text-gray-600 text-sm">
            <p>Self-Evolution Skill v1.0 - Â© 2026 Bobo</p>
            <p class="mt-1">Meta-level skill for Claude Code optimization</p>
        </div>
    </footer>

    <script>
        // æ•°æ®åŠ è½½
        const DATA_DIR = './data';

        // å®‰å…¨çš„ DOM åˆ›å»ºè¾…åŠ©å‡½æ•°
        function createElement(tag, props = {}, ...children) {
            const el = document.createElement(tag);
            Object.entries(props).forEach(([key, value]) => {
                if (key === 'className') {
                    el.className = value;
                } else if (key.startsWith('on')) {
                    el.addEventListener(key.slice(2).toLowerCase(), value);
                } else {
                    el.setAttribute(key, value);
                }
            });
            children.forEach(child => {
                if (typeof child === 'string') {
                    el.appendChild(document.createTextNode(child));
                } else if (child) {
                    el.appendChild(child);
                }
            });
            return el;
        }

        // åŠ è½½å¹¶æ˜¾ç¤ºæ•°æ®
        async function loadDashboardData() {
            try {
                // æ›´æ–°æ—¶é—´æˆ³
                document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString('zh-CN');

                // åŠ è½½å„ä¸ªéƒ¨åˆ†
                await loadExecutionStats();
                await loadQualityTrends();
                await loadRecentExecutions();
                await loadPatterns();
                await loadTemplates();
                await loadSchedulerStatus();

            } catch (error) {
                console.error('Error loading dashboard data:', error);
            }
        }

        // åŠ è½½æ‰§è¡Œç»Ÿè®¡
        async function loadExecutionStats() {
            try {
                const response = await fetch(`${DATA_DIR}/executions/index.json`);
                if (!response.ok) throw new Error('Index not found');

                const data = await response.json();
                const executions = data.executions || [];

                // è¿‡æ»¤æœ€è¿‘30å¤©
                const thirtyDaysAgo = Date.now() - 30 * 24 * 60 * 60 * 1000;
                const recent = executions.filter(e =>
                    new Date(e.timestamp).getTime() > thirtyDaysAgo
                );

                document.getElementById('totalExecutions').textContent = recent.length;

            } catch (error) {
                console.error('Error loading execution stats:', error);
                document.getElementById('totalExecutions').textContent = '0';
            }
        }

        // åŠ è½½è´¨é‡è¶‹åŠ¿å›¾è¡¨
        async function loadQualityTrends() {
            try {
                const response = await fetch(`${DATA_DIR}/weights/latest.json`);
                if (!response.ok) throw new Error('Weights not found');

                const data = await response.json();
                const weights = data.weights || {};

                // è®¡ç®—å¹³å‡è´¨é‡
                const values = Object.values(weights);
                const avgQuality = values.length > 0
                    ? (values.reduce((a, b) => a + b, 0) / values.length).toFixed(3)
                    : '0.000';

                document.getElementById('avgQuality').textContent = avgQuality;

                // åˆ›å»ºå›¾è¡¨
                const ctx = document.getElementById('qualityChart').getContext('2d');

                // æ¨¡æ‹Ÿè¶‹åŠ¿æ•°æ®ï¼ˆå®é™…åº”è¯¥ä»å†å²æ•°æ®ä¸­è·å–ï¼‰
                const labels = Array.from({length: 30}, (_, i) => {
                    const d = new Date();
                    d.setDate(d.getDate() - (29 - i));
                    return d.toLocaleDateString('zh-CN', {month: 'short', day: 'numeric'});
                });

                const baseQuality = parseFloat(avgQuality);
                const trendData = Array.from({length: 30}, () =>
                    Math.max(0, Math.min(1, baseQuality + (Math.random() - 0.5) * 0.1))
                );

                new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'å¹³å‡è´¨é‡åˆ†æ•°',
                            data: trendData,
                            borderColor: '#3b82f6',
                            backgroundColor: 'rgba(59, 130, 246, 0.1)',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.4
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        plugins: {
                            legend: {
                                display: false
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                max: 1,
                                ticks: {
                                    callback: function(value) {
                                        return value.toFixed(2);
                                    }
                                }
                            }
                        }
                    }
                });

            } catch (error) {
                console.error('Error loading quality trends:', error);
                document.getElementById('avgQuality').textContent = '0.00';
            }
        }

        // åŠ è½½æœ€è¿‘æ‰§è¡Œè®°å½•
        async function loadRecentExecutions() {
            const container = document.getElementById('recentExecutions');
            container.textContent = '';  // æ¸…ç©º

            try {
                const response = await fetch(`${DATA_DIR}/executions/index.json`);
                if (!response.ok) throw new Error('Index not found');

                const data = await response.json();
                const executions = (data.executions || []).slice(-10).reverse();

                if (executions.length === 0) {
                    const msg = createElement('p', {className: 'text-gray-500 text-center py-8'}, 'æš‚æ— æ‰§è¡Œè®°å½•');
                    container.appendChild(msg);
                    return;
                }

                executions.forEach(exec => {
                    const item = createElement('div', {className: 'border-l-4 border-blue-500 pl-4 py-2'});

                    const header = createElement('div', {className: 'flex items-center justify-between'});
                    const skillName = createElement('span', {className: 'font-semibold text-gray-800'}, exec.skill_name || 'Unknown');
                    const timestamp = createElement('span', {className: 'text-xs text-gray-500'},
                        new Date(exec.timestamp).toLocaleString('zh-CN'));
                    header.appendChild(skillName);
                    header.appendChild(timestamp);

                    const sessionInfo = createElement('div', {className: 'text-sm text-gray-600 mt-1'});
                    sessionInfo.appendChild(document.createTextNode('Session: ' + exec.session_id));

                    item.appendChild(header);
                    item.appendChild(sessionInfo);
                    container.appendChild(item);
                });

            } catch (error) {
                console.error('Error loading recent executions:', error);
                const msg = createElement('p', {className: 'text-gray-500 text-center py-8'}, 'åŠ è½½å¤±è´¥');
                container.appendChild(msg);
            }
        }

        // åŠ è½½æ¨¡å¼æ•°æ®
        async function loadPatterns() {
            const container = document.getElementById('successPatterns');
            container.textContent = '';  // æ¸…ç©º

            try {
                const response = await fetch(`${DATA_DIR}/patterns/latest.json`);
                if (!response.ok) throw new Error('Patterns not found');

                const data = await response.json();
                const patterns = data.success_patterns || [];

                document.getElementById('patternsCount').textContent = patterns.length;

                if (patterns.length === 0) {
                    const msg = createElement('p', {className: 'text-gray-500 text-center py-8'}, 'æš‚æ— å‘ç°çš„æ¨¡å¼');
                    container.appendChild(msg);
                    return;
                }

                patterns.slice(0, 5).forEach((pattern, i) => {
                    const item = createElement('div', {className: 'border rounded-lg p-4 hover:shadow-md transition'});

                    const header = createElement('div', {className: 'flex items-center justify-between mb-2'});
                    const title = createElement('span', {className: 'font-semibold text-gray-800'}, `æ¨¡å¼ #${i + 1}`);
                    const badge = createElement('span', {className: 'badge badge-success'},
                        `è´¨é‡: ${(pattern.avg_quality || 0).toFixed(2)}`);
                    header.appendChild(title);
                    header.appendChild(badge);

                    const stats = createElement('div', {className: 'text-sm text-gray-600'});
                    stats.textContent = `ä½¿ç”¨æ¬¡æ•°: ${pattern.usage_count || 0} | æ”¯æŒåº¦: ${((pattern.support || 0) * 100).toFixed(1)}%`;

                    item.appendChild(header);
                    item.appendChild(stats);
                    container.appendChild(item);
                });

            } catch (error) {
                console.error('Error loading patterns:', error);
                document.getElementById('patternsCount').textContent = '0';
                const msg = createElement('p', {className: 'text-gray-500 text-center py-8'}, 'åŠ è½½å¤±è´¥');
                container.appendChild(msg);
            }
        }

        // åŠ è½½æ¨¡æ¿æ•°æ®
        async function loadTemplates() {
            const container = document.getElementById('templatesLibrary');
            container.textContent = '';  // æ¸…ç©º

            try {
                const response = await fetch(`${DATA_DIR}/templates/latest.json`);
                if (!response.ok) throw new Error('Templates not found');

                const data = await response.json();
                const templates = data.templates || [];

                document.getElementById('templatesCount').textContent = templates.length;

                if (templates.length === 0) {
                    const msg = createElement('p', {className: 'text-gray-500 text-center py-8 col-span-full'}, 'æš‚æ— å¯ç”¨æ¨¡æ¿');
                    container.appendChild(msg);
                    return;
                }

                templates.slice(0, 6).forEach(tmpl => {
                    const item = createElement('div', {className: 'border rounded-lg p-4 hover:shadow-lg transition cursor-pointer'});

                    const title = createElement('h3', {className: 'font-bold text-gray-800 mb-2'}, tmpl.name);

                    const badges = createElement('div', {className: 'flex flex-wrap gap-1 mb-3'});
                    badges.appendChild(createElement('span', {className: 'badge badge-info'}, tmpl.category));
                    badges.appendChild(createElement('span', {className: 'badge badge-warning'}, tmpl.tech_stack));
                    badges.appendChild(createElement('span', {className: 'badge badge-success'}, tmpl.complexity));

                    const quality = createElement('div', {className: 'text-xs text-gray-500'});
                    quality.textContent = `è´¨é‡: ${(tmpl.metadata.avg_quality_score || 0).toFixed(2)} | ä½¿ç”¨: ${tmpl.metadata.usage_count || 0}æ¬¡`;

                    const placeholders = createElement('div', {className: 'mt-2 text-xs text-gray-600'});
                    placeholders.textContent = `å ä½ç¬¦: ${Object.keys(tmpl.placeholders || {}).length}ä¸ª`;

                    item.appendChild(title);
                    item.appendChild(badges);
                    item.appendChild(quality);
                    item.appendChild(placeholders);
                    container.appendChild(item);
                });

            } catch (error) {
                console.error('Error loading templates:', error);
                document.getElementById('templatesCount').textContent = '0';
                const msg = createElement('p', {className: 'text-gray-500 text-center py-8 col-span-full'}, 'åŠ è½½å¤±è´¥');
                container.appendChild(msg);
            }
        }

        // åŠ è½½è°ƒåº¦å™¨çŠ¶æ€
        async function loadSchedulerStatus() {
            const container = document.getElementById('schedulerStatus');
            container.textContent = '';  // æ¸…ç©º

            try {
                const response = await fetch(`${DATA_DIR}/last_run.json`);
                if (!response.ok) throw new Error('Last run not found');

                const lastRun = await response.json();
                const tasks = [
                    'daily_optimization',
                    'weekly_pattern_discovery',
                    'weekly_template_generation',
                    'weekly_knowledge_transfer',
                    'weekly_framework_evolution',
                    'weekly_report'
                ];

                const grid = createElement('div', {className: 'grid grid-cols-1 md:grid-cols-2 gap-4'});

                tasks.forEach(taskName => {
                    const lastRunTime = lastRun[taskName];
                    const hasRun = !!lastRunTime;
                    const timeAgo = hasRun
                        ? getTimeAgo(new Date(lastRunTime))
                        : 'ä»æœªè¿è¡Œ';

                    const item = createElement('div', {className: 'border rounded-lg p-4'});

                    const header = createElement('div', {className: 'flex items-center justify-between mb-2'});
                    const name = createElement('span', {className: 'font-semibold text-gray-800'}, taskName);
                    const badge = createElement('span', {
                        className: hasRun ? 'badge badge-success' : 'badge badge-warning'
                    }, hasRun ? 'å·²è¿è¡Œ' : 'å¾…è¿è¡Œ');
                    header.appendChild(name);
                    header.appendChild(badge);

                    const info = createElement('div', {className: 'text-sm text-gray-600'});
                    info.textContent = `æœ€åè¿è¡Œ: ${timeAgo}`;

                    item.appendChild(header);
                    item.appendChild(info);
                    grid.appendChild(item);
                });

                container.appendChild(grid);

            } catch (error) {
                console.error('Error loading scheduler status:', error);
                const msg = createElement('p', {className: 'text-gray-500 text-center py-8'}, 'åŠ è½½å¤±è´¥æˆ–è°ƒåº¦å™¨æœªè¿è¡Œ');
                container.appendChild(msg);
            }
        }

        // è¾…åŠ©å‡½æ•°ï¼šè®¡ç®—æ—¶é—´å·®
        function getTimeAgo(date) {
            const seconds = Math.floor((new Date() - date) / 1000);

            if (seconds < 60) return `${seconds} ç§’å‰`;
            const minutes = Math.floor(seconds / 60);
            if (minutes < 60) return `${minutes} åˆ†é’Ÿå‰`;
            const hours = Math.floor(minutes / 60);
            if (hours < 24) return `${hours} å°æ—¶å‰`;
            const days = Math.floor(hours / 24);
            return `${days} å¤©å‰`;
        }

        // åˆå§‹åŠ è½½
        loadDashboardData();

        // æ¯åˆ†é’Ÿè‡ªåŠ¨åˆ·æ–°
        setInterval(loadDashboardData, 60000);
    </script>
</body>
</html>
